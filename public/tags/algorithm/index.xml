<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ALGORITHM on My New Hugo Site</title>
    <link>https://vincent-s-blog.web.app/tags/algorithm/</link>
    <description>Recent content in ALGORITHM on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us, zh-TW, zh</language>
    <lastBuildDate>Tue, 19 Dec 2023 19:55:38 +0800</lastBuildDate><atom:link href="https://vincent-s-blog.web.app/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何使用 C 語言實作 HeapTree</title>
      <link>https://vincent-s-blog.web.app/posts/algorithm/heaptree01/</link>
      <pubDate>Tue, 19 Dec 2023 19:55:38 +0800</pubDate>
      
      <guid>https://vincent-s-blog.web.app/posts/algorithm/heaptree01/</guid>
      <description>引言 什麼是 HeapTree 123123123123123123 Lorem ipsum dolor sit amet, officia excepteur ex fugiat reprehenderit enim labore culpa sint ad nisi Lorem pariatur mollit ex esse exercitation amet. Nisi anim cupidatat excepteur officia. Reprehenderit nostrud nostrud ipsum Lorem est aliquip amet voluptate voluptate dolor minim nulla est proident. Nostrud officia pariatur ut officia. Sit irure elit esse ea nulla sunt ex occaecat reprehenderit commodo officia dolor Lorem duis laboris cupidatat officia voluptate.</description>
    </item>
    
    <item>
      <title>如何使用 C 語言實作Linked List</title>
      <link>https://vincent-s-blog.web.app/posts/algorithm/linkedlist01/</link>
      <pubDate>Sun, 26 Nov 2023 22:13:35 +0800</pubDate>
      
      <guid>https://vincent-s-blog.web.app/posts/algorithm/linkedlist01/</guid>
      <description>前言 一般在宣告陣列的時候會需要定義陣列的長度，像是：
const int MAXN = 1005; int main() { int arr[MAXN]; // 宣告一個長度為 1005 的整數陣列 } 陣列的記憶體是連續的，所以我們可以很容易使用迴圈遍歷陣列的每一個元素。
void printArray(int *ptr, int *endptr) { while(ptr != endptr) { cout &amp;lt;&amp;lt; *ptrk++ &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; *ptr &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; return; } 1 2 3 4 5 LinkedList 是一個可以根據存放資料多寡而擴充的一種資料結構，不需要在宣告的時候就定義長度，這讓我們避免多開了不必要的記憶體。 它由節點（Node）組成，每個節點包含數據和一個指向下一個節點的指針。鏈表有幾種主要的類型，包括單向鏈表、雙向鏈表和循環鏈表。這裡列舉一下鏈表的優缺點：
優點 動態內存分配： 鏈表的大小可以在運行時動態調整，因此不需要在一開始就分配固定大小的內存。這使得鏈表更靈活，可以有效地利用內存。
插入和刪除操作高效： 插入和刪除節點的操作在鏈表中比較高效。對於單向鏈表，如果你有指向插入位置的指針，可以在 O(1) 時間內完成插入操作。刪除操作也類似，只需調整相鄰節點的指針即可。
不需要預先分配空間： 與數組（Array）不同，鏈表不需要事先分配空間，因此在添加元素時不需要考慮容量的問題。 高度擴充性
缺點 隨機訪問效率低： 訪問鏈表中的某一個元素需要從頭部開始遍歷，直到找到所需元素。這導致鏈表的隨機訪問效率較低，時間複雜度為 $O(n)$。
線性存儲： 鏈表中的元素在內存中並不是連續存放的，這可能導致對緩存的效率較低。
實作 LinkedList 定義 Struct 你需要先定義一個結構來儲存節點(Node)以及鏈結(Link)。</description>
    </item>
    
  </channel>
</rss>
