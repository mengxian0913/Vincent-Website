<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on My New Hugo Site</title>
    <link>https://vincent-s-blog.web.app/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us, zh-TW, zh</language>
    <lastBuildDate>Tue, 19 Dec 2023 19:55:38 +0800</lastBuildDate><atom:link href="https://vincent-s-blog.web.app/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何使用 C 語言實作 HeapTree</title>
      <link>https://vincent-s-blog.web.app/posts/algorithm/heaptree01/</link>
      <pubDate>Tue, 19 Dec 2023 19:55:38 +0800</pubDate>
      
      <guid>https://vincent-s-blog.web.app/posts/algorithm/heaptree01/</guid>
      <description>引言 什麼是 HeapTree 123123123123123123 Lorem ipsum dolor sit amet, officia excepteur ex fugiat reprehenderit enim labore culpa sint ad nisi Lorem pariatur mollit ex esse exercitation amet. Nisi anim cupidatat excepteur officia. Reprehenderit nostrud nostrud ipsum Lorem est aliquip amet voluptate voluptate dolor minim nulla est proident. Nostrud officia pariatur ut officia. Sit irure elit esse ea nulla sunt ex occaecat reprehenderit commodo officia dolor Lorem duis laboris cupidatat officia voluptate.</description>
    </item>
    
    <item>
      <title>計概作業 5 演算法十八般武藝</title>
      <link>https://vincent-s-blog.web.app/posts/algorithm/blog-test/</link>
      <pubDate>Tue, 08 Aug 2023 22:49:50 +0800</pubDate>
      
      <guid>https://vincent-s-blog.web.app/posts/algorithm/blog-test/</guid>
      <description>704. Binary Search 二分搜解法 $O(log_2n)$ 因為每次搜尋都會將資料切半，所以時間複雜度為 $O(log_{2}n)$
二分搜尋實作(左閉右閉)
將數據由小至大排序好 設定左界及右界 尋找中間(mid) 如果數值 arr[mid] 大於 目標，將右指針移動到 mid-1 如果數值 arr[mid] 小於 目標，將左指針移動到 mid+1 如果數值 arr[mid] 等於 目標，回傳答案 class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; arr, int target) { sort(arr.begin(), arr.end()); int Lptr = 0, Rptr = (int)arr.size()-1; while(Lptr &amp;lt;= Rptr) { long long mid = (Lptr + Rptr) / 2; if(arr[mid] == target) return mid; else if(arr[mid] &amp;lt; target) Lptr = mid + 1; else Rptr = mid - 1; } return -1; } }; 線性搜尋尋 $O(n)$ 線性搜尋實作</description>
    </item>
    
  </channel>
</rss>
