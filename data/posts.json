[
  {
    "title": "計概作業 5 演算法十八般武藝",
    "date": "2023-08-08T14:49:50.000Z",
    "content": "\n## [704. Binary Search](https://leetcode.com/problems/binary-search/)\n\n### 二分搜解法 $O(log_2n)$\n>因為每次搜尋都會將資料切半，所以時間複雜度為 $O(log_{2}n)$\n\n**二分搜尋實作(左閉右閉)**\n\n1. 將數據由小至大排序好\n2. 設定左界及右界\n3. 尋找中間(mid)\n4. 如果數值 arr[mid] 大於 目標，將右指針移動到 mid-1\n5. 如果數值 arr[mid] 小於 目標，將左指針移動到 mid+1\n6. 如果數值 arr[mid] 等於 目標，回傳答案\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& arr, int target) {\n        sort(arr.begin(), arr.end());\n        int Lptr = 0, Rptr = (int)arr.size()-1;\n\n        while(Lptr <= Rptr)\n        {\n            long long mid = (Lptr + Rptr) / 2;\n            if(arr[mid] == target) return mid;\n\n            else if(arr[mid] < target) Lptr = mid + 1;\n\n            else Rptr = mid - 1;\n        }\n        return -1;\n    }\n};\n```\n\n---\n\n### 線性搜尋尋 $O(n)$\n\n**線性搜尋實作**\n\n1. 比較數據中每一個值\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& arr, int target) {\n        for(int i=0;i<(int)arr.size(); i++)\n        {\n            if(arr[i] == target) return i;\n        }\n        return -1;\n    }\n};\n```\n\n## [912. Sort an Array](https://leetcode.com/problems/sort-an-array/)\n\n\n### 數據值域\n\n![](https://i.imgur.com/7VGsI5o.png)\n\n排序的時間複雜度主要考慮的是array的長度，題目給的最大長度為 $5\\times10^{4}$\n\n所以要選擇複雜度較低的演算法，像是 $O(n^{2})$ 就肯定不會過。\n\n<span class=\"light\">ps.程式 1 秒大概可以跑 $10^{9}$ 的資料量。</span>\n\n以下介紹幾種常見的排序演算法><\n\n---\n\n### 泡泡排序(Bubble Sort) $O(n^2)$ <font color='#FFD306'>**TLE**</font>\n\n![image alt](https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif)\n\n**泡泡排序實作** \n\n它重複地走訪過要排序的數列，一次比較兩個元素，如果它們的順序錯誤就把它們交換過來。走訪數列的工作是重複地進行直到沒有再需要交換，也就是說該數列已經排序完成。這個演算法的名字由來是因為越小的元素會經由交換慢慢「浮」到數列的頂端。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& arr) {\n\t\tfor(int i=(int)arr.size()-1;i>=0; i--)\n\t\t{\n\t\t\tfor(int k=0;k<i; k++)\n\t\t\t{\n\t\t\t\tif(arr[k] > arr[k+1]) swap(arr[k], arr[k+1]);\n\t\t\t}\n\t\t}\n    \n    \treturn arr;\n    }\n};\n```\nTime Complexity Proof: <br>\n$lim_{n \\to \\infty}[n+(n-1)+(n-2)+(n-3)+ ... + 1]=O(n^2)$\n\n---\n\n### 插入排序(Insertion Sort) $O(n^2)$ <font color='#FFD306'>**TLE**</font>\n\n![image alt](https://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif)\n\n**插入排序實作**\n\n第一個指針指向要插入的值，第二個指針尋找要插入的位置(當 第一個指針的值要放在小於等於他的值後面)，第二個指針移動的時候，如果前面條件不符合，就會將大於第一個指針值得值往後移動。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& arr) {\n\t\tint len = (int)arr.size();\n\t\t\n\t\tint i, j, tmp = 0;\n\t\t\n\t\tfor(i = 1; i < len; i++)\n\t\t{\n\t\t\ttmp = arr[i];\n\t\t\t\n\t\t\tfor(j = i; j > 0 && tmp < arr[j - 1]; j--)\n\t\t\t{\n\t\t\t\tarr[j] = arr[j-1];\n\t\t\t}\n\t\t\t\n\t\t\tarr[j] = tmp;\n\t\t}\n\t\t\n\t\treturn arr;\n    }\n};\n```\n\nTime Complexity:\n1. 最好的情况：最好的情况就是待排序的數據已經排好序了，这时只需要進行 $(n-1)$ 次比較操作。\n2. 最壞的情况：最壞的情况就是待排序的數據序列是逆序的。此时需要進行的比較次數為 $n(n-1)/2$ 次，賦值操作是比較操作的次数 $n(n-1)/2+(n-1)$ 次。平均來說插入排序算法的時間複雜度為$O(n^2)$。<br>\n\n<span class=\"light\">注：插入排序不是和對於數據量比較大的排序應用。</span>\n\n---\n\n### 選擇排序(Selection Sort) $O(n^2)$ <font color='#FFD306'>**TLE**</font>\n\n![image alt](https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif)\n\n**選擇排序實作**\n\n作法概念類似泡泡排序\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& arr) {\n\t\tint len = (int)arr.size();\n\t\t\n\t\tint index = 0, minind = -1, minval = 1e18;\n\t\t\n\t\tfor(int i = 0; i < len; i++)\n\t\t{\n\t\t\tminval = 1e18;\n\t\t\tfor(int k = i; k < len; k++)\n\t\t\t{\n\t\t\t\tif(arr[k] < minval)\n\t\t\t\t{\n\t\t\t\t\tminind = k;\n\t\t\t\t\tminval = arr[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tswap(arr[minind], arr[i]);\n\t\t}\n\t\t\n\t\treturn arr;\n    }\n};\n```\n\n---\n\n### 合併排序(Merge Sort) $O(n\\times log_{2}n)$ \n\n![image alt](https://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif)\n\n<span class=\"info\">利用分治概念進行排序</span>\n\n\n<span class=\"warning\">穩定的 $O(n\\times log_{2}n)$</span>\n\n\n**合併排序演算法步驟：**\n\n1. 邊界條件：序列長度為 1 ⇒ 不用做任何事就已經排序好了。\n2. 把序列從中間切成左右兩半。\n3. 遞迴排序左半邊。\n4. 遞迴排序右半邊。\n5. 把左半邊跟右半邊的序列合併起來。\n\n### 常數較大版本 <font color='#FFD306'>**TLE**</font>\n\n```cpp\n#define pb push_back\n\nclass Solution {\npublic:\n    vector<int> mergesort(vector<int> arr) {\n\t\t\n\t\tint len = (int)arr.size();\n\t\n\t\tif(len == 1) return arr;\n\t\t\n\t\tint mid = len / 2;\n\t\tvector<int>right, left;\n\t\t\n\t\tfor(int i=0; i<len; i++)\n\t\t{\n\t\t\tif(i < mid) left.pb(arr[i]);\t\n\t\t\telse right.pb(arr[i]);\n\t\t}\n\t\t\n\t\tleft = mergesort(left);\n\t\tright = mergesort(right);\n\t\t\n\t\tvector<int>sorted;\n\t\tint Lptr = 0, Rptr = 0;\n\t\t\n\t\twhile(Lptr < (int)left.size() && Rptr < (int)right.size())\n\t\t{\n \t\t\tif(left[Lptr] < right[Rptr])\n\t\t\t{\n\t\t\t\tsorted.pb(left[Lptr++]);\n\t\t\t}\n\t\t\t\n\t\t\telse\n\t\t\t{\n\t\t\t\tsorted.pb(right[Rptr++]);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(Lptr < (int)left.size())\n\t\t{\n\t\t\tsorted.pb(left[Lptr++]);\n\t\t}\n\t\t\n\t\twhile(Rptr < (int)right.size())\n\t\t{\n\t\t\tsorted.pb(right[Rptr++]);\n\t\t}\n\n\t\treturn sorted;\n    }\n};\n```\n\n\n### 常數較小版本 <font color='#8CEA00'>AC</font>\n```cpp\n#define pb push_back\n\nclass Solution {\npublic:\n    void mergesort(int l, int r, vector<int>&arr) {\n\n        // 邊 界 條 件： 陣 列 長 度 等 於 1\n        if (l == r) return;\n        \n        // 遞 迴 排 序 左 半 邊 跟 右 半 邊\n        int mid = (l+r)/2;\n        mergesort(l, mid, arr);\n        mergesort(mid+1, r, arr);\n        \n        // 合 併 左 右 兩 半 邊\n        vector<int> sorted;\n        int Lptr = l, Rptr = mid+1;\n        \n        while (Lptr <= mid && Rptr <= r) {\n        \n            if (arr[Lptr] < arr[Rptr]) {\n                sorted.push_back(arr[Lptr]);\n                Lptr++;\n            } \n            \n            else {\n                sorted.push_back(arr[Rptr]);\n                Rptr++;\n            }\n        \n        }\n        \n        while (Lptr <= mid) {\n            sorted.push_back(arr[Lptr]);\n            Lptr++;\n        }\n        while (Rptr <= r) {\n            sorted.push_back(arr[Rptr]);\n            Rptr++;\n        }\n        \n        for (int i = l, j = 0; i <= r; i++, j++) {\n            arr[i] = sorted[j];\n        }\n    }\n\n    vector<int> sortArray(vector<int> arr) {\n\t\tmergesort(0, (int)arr.size()-1, arr);\n        return arr;\n    }\n};\n```\n\nTime Complexity Proof\n我們把遞迴的過程畫出來，會發現它是一顆樹狀圖，稱之「遞迴樹」\n![](https://i.imgur.com/pXcH6zw.png)\n* 只要把樹上每個節點的時間複雜度加總，就可以知道合併排序的複雜度了。\n* 合併兩個序列的複雜度是線性的。\n* 故每個節點的複雜度為 $O(L)$，這裡的 $L$ 是指該節點對應到的序列長度。\n* 用一層一層的角度來看，每層遞迴總複雜度 $O(n)$，$n$ 是指原本整個序列的大小。\n* 而因為一直切一半的關係，所以遞迴總共 $O(log n)$ 層。\n![](https://i.imgur.com/1nJo0ZR.png)\n\n\n\n---\n\n### 快速排序 (Quick Sort) $O(n\\times log_{2}n)$ <font color='#FFD306'>**TLE**</font>\n\n![image alt](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)\n\n\n平均時間複雜度為 $O(n\\times log_{2}n)$\n但是數據如果剛好與我們目標排序規則相反，時間複雜度會退化到 $O(n^2)$\n\n\n**快速排序法實作步驟**\n\n\n1. 選定陣列一個位置(我習慣都取第一個) ```int n = arr[0]```\n2. 小於 n 的值放左邊\n3. 大於等於 n 的值放右邊\n4. 左右遞迴\n5. 合併\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define all(aa) aa.begin(),aa.end() \n\nvector<int> q_sort(vector<int>& arr)\n{\n\tint len = (int)arr.size();\n\t\t\n\tif(len <= 2)\n\t{\n\t\tif(len <= 1)\n\t\t{\n\t\t\treturn arr;\n\t\t} \n\t\tif(arr[0] > arr[1])\n\t\t{\n\t\t\tswap(arr[0], arr[1]);\n\t\t}\n\t\treturn arr;\n\t}\n\t\t\n\tint now = arr[0];\n\t\n\tvector<int>left, right;\n\t\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tif(arr[i] < now) left.pb(arr[i]);\n\t\telse right.pb(arr[i]);\n\t}\n\n\tvector<int> left_sort = q_sort(left);\n\tvector<int> right_sort = q_sort(right);\n\t\n\tvector<int> sorted;\n\t\n\tfor(int i=0;i<(int)left_sort.size(); i++)\n\t{\n\t\tsorted.pb(left_sort[i]);\n\t}\n\t\n\tsorted.pb(now);\n\t\n\tfor(int i=0;i<(int)right_sort.size();i++)\n\t{\n\t\tsorted.pb(right_sort[i]);\n\t}\n\t\n\treturn sorted;\n}\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> arr(n);\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin >> arr[i];\n\t}\n\t\n\tvector<int> sorted = q_sort(arr);\n\n\tfor(int i:sorted)\n\t{\n\t\tcout << i << \" \";\n\t}\n\t\n\tcout << \"\\n\";\n\t\n\treturn;\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tsolve();\n\treturn 0;\n}\n```\nTime Complexity Proof:<br>\n證明方法同於合併排序\n\n\n",
    "url": "https://vincent-s-blog.web.app/posts/algorithm/blog-test/"
  },
  {
    "title": "2023 暑期人工智能交流",
    "date": "2023-08-08T15:02:15.000Z",
    "content": "\n<center> \n\n{{< youtube b9EzcKGGs44>}}\n\n</center>\n\n\n## 前言：\n\n本次活動為 同濟大學、香港理工大學、澳門科技大學、世新大學、逢甲大學 等五校一同舉辦九天的人共智能交流活動。\n此活動共有 109 為師生，並且總共有四種不同的課題。\n其中包含： <span class=\"light\">智慧出行、人工智能倫理、跨海大橋、智慧城市</span>\n\n這九天會參訪許多內地知名的高科技產業，例如：深城交、優必選；如此之外，也到許多重點大學參訪，例如：香港理工大學、香港中文大學、澳門科技大學等等。\n\n我是這次課程 <span class=\"success\">智慧出行</span> 課題的學生。<br>\n\n**此篇文章主要分為三個部分：**\n<font color=\"yellow\">1.活動經歷 2. 課程想法 3. 活動心得</font>\n\n---\n\n## 活動經歷\n\n### <span class=\"info\">參訪比亞迪</span>\n\n{{< swiper \"/images/Posts/暑期聯合大學人工智能活動/BYD\" \"1\">}}\n\n深圳的道路上大概有 8 ~ 9 成的汽車都是電動能源車，而這些車輛大多出廠於 **比亞迪(BYD)**。\n在行程第一天我們參訪比亞迪，了解這間公司的技術，其中包含了電動車(EV)、混合  動力車(HEV)、刀片電池，以及能源系統等等。\n除了新能源汽車製造外，比亞迪也幫許多知名手機品牌代工。\n\n- 電動汽車（EV）：比亞迪是電動汽車領域的重要參與者之一。公司生產各種類型的電動車輛，包括乘用車、商用車和公交車。比亞迪在電動巴士製造方面取得了顯著成就，成為全球最大的電動巴士製造商之一。\n- 混合動力汽車（HEV）：除了純電動車輛，比亞迪還製造混合動力汽車，將傳統內燃機與電動技術相結合，提高燃油效率和減少排放。\n- 新能源技術：比亞迪在電池技術領域取得突破，開發鋰鐵磷酸鐵鋰電池等先進電池技術，用於驅動其電動車輛和儲能系統。\n- 太陽能電池板：比亞迪也涉足太陽能電池板製造領域，生產用於太陽能發電系統的組件和設備。\n- 儲能系統：公司還生產電池儲能系統，用於儲存和管理電力，支持電網平衡和可再生能源集成。\n\n### <span class=\"info\">參訪優必選、深城交</span>\n\n{{< swiper \"/images/Posts/暑期聯合大學人工智能活動/深城交和優必選\" \"2\">}}\n\n**深城交**是一家專注於城市交通領域的國家級高新技術企業，提供城市交通整體解決方案，包括規劃、設計、整合、運營等服務。以下是深城交提供的幾項服務：\n\n- 規劃諮詢：提供城市交通規劃、軌道交通規劃、道路交通規劃、公共交通規劃等等。\n- 工程設計和檢測：提供道路工程設計、橋樑工程設計、隧道工程設計、軌道工程設計、機電工程設計等等。\n- 大數據軟體及**智慧交通**：提供交通大數據平台、综合交通仿真平台、智慧停車平台、車路協同平台、智慧出行平台等專業軟體產品，以及智慧城市、智慧街區、智慧道路等專業系统集成方案，為客户提供數據驅動和智能化的解决方案。<br>\n\n**優必選**是一家中國的機器人製造商，核心技術如下：\n\n- 動作程序程式設計：可以讓機器人學習和執行不同的動作\n- 語音交互：可以讓機器人聽懂和回答語音指令，例如查詢天氣、時間、詩詞等\n- 智能通話：可以讓機器人透過視頻和聲音與遠方的人聯繫\n- 人臉識別：可以讓機器人辨認不同的人臉，並根據情況做出相應的反應\n- 物體識別：可以讓機器人識別不同的物體，例如繪本、玩具等\n- 圖形編程：可以讓機器人通過圖形化的界面進行編程，學習邏輯思維和創造力\n\n### <span class=\"info\">國家基因庫</span>\n\n{{< swiper \"/images/Posts/暑期聯合大學人工智能活動/國家基因庫\" \"3\">}}\n\n國家基因庫是一個專門收集和保存各種生物樣本和數據的機構。\n\n- 保存、保護和合理利用基因資源，為國家安全和核心競爭力提供堅實基礎和有效保障。\n- 建設成為引領我國生命科學和生物經濟發展的戰略性科技力量，支撐生命科學研究與生物產業創新發展的公益性、開放性、引領性、戰略性科技平台。\n- 推動行業內的學術交流和樣本/數據資源共享，促進生命資源的科學合理應用，實現全球資源保護和戰略性應用。\n- 為科研工作者、相關產業的從業者和普通民眾創造學術交流、人才培訓、科普教育的廣闊空間與寶貴機遇，提升領域內人才的理論與實踐能力，培養民眾的科學態度與科學精神。\n\n\n### <span class=\"info\">香港立法會</span>\n\n{{< swiper \"/images/Posts/暑期聯合大學人工智能活動/香港立法院\" \"4\">}}\n\n參訪香港立法院，香港立法會<font style=\"text-decoration: underline;\"> **洪雯** </font>議員合照。\n\n---\n\n## 課程想法 (對於全自動駕駛的想法)\n\n本次課程中，老師給予同學們開放式的討論機會，就自動駕駛技術的可行性和實現方法進行了熱烈的交流。以下對不同組別的觀點進行簡要總結：\n\n\n我們認為實現自動駕駛技術需要著重發展三大關鍵技術：\n\n\n1. 即時地圖資訊：\n    - 路線規劃： 在全自動駕駛中，我們提議利用高精度地圖來精確定位車輛所處車道，同時透過雲端計算規劃最佳路線。\n    - 道路規範： 不同道路有不同規則，如限速等。我們建議將這些道路規則存儲在雲端，車輛根據當前規範行駛。這樣做的優點是方便維護，但缺點是可能受到黑客攻擊。\n2. 車輛計算機系統：\n    - 在面對緊急或特殊情況（如前車急煞或障礙物）時，我們需要車輛內部的辨識系統和訓練良好的決策模型做出即時決策。車輛之間的溝通也至關重要。\n    - 統一計算規則：針對超車等情況，我們建議制定統一計算規則，以避免不同車輛制定矛盾決策。我們認為不同自動駕駛車輛應共享一套統一的計算機系統，以確保一致性且能互相溝通。\n3. 區塊鏈技術：\n    - 我們提出區塊鏈技術可用於減輕雲端計算的壓力。例如，將道路劃分為不同區塊（如 A、B、C、D），若在某區塊發生事故，僅需要在該區塊更新相關資訊，而不需將所有資訊返回雲端進行計算。車輛在行駛於該區塊時，能接收到相關訊息並做出適當決策。\n\n我們相信，未來的自動駕駛技術將不僅僅是一種交通工具的變革，更是一場科技和創新的融合。通過我們共同的努力，我們有機會實現這些技術的突破和應用，為社會帶來更便捷、更安全的出行方式。\n\n\n---\n\n## 活動心得\n\n{{< swiper \"/images/Posts/暑期聯合大學人工智能活動/心得照片\" \"5\">}}\n\n\n這次活動跨足陸地、港澳三地，與不同地區的學生進行交流。白天，同濟大學的導師帶領我們進行了課程學習和科技企業參觀。夜晚，當地的學生自發地帶領我們遊覽當地著名景點，這些畫面被相機的快門定格，成為難以磨滅的回憶。在這幾天裡，我們不僅學到專業知識，也在課餘時充分享受了美好時光。\n\n在香港，我們在酒店旁的酒吧中，盡情享受著酣暢淋漓的歡樂，無所不談。在酒精的作用下，我們毫無保留地分享著各自家鄉的特色，以及對兩岸事務的看法。這樣的交流使我們更真實地理解了彼此，加深了我們之間的連結。\n\n九天的交流時間匆匆而過，轉眼間，我們已經要與初次相識的朋友們告別了。然而，未來我們仍將返回各自的生活圈，繼續拼搏。我們約定，在各自遊覧對方家鄉時，將作為導遊相互招待。這次交流活動的價值在於它不是完美的結局，而是成功地建立起兩岸友好的橋樑。\n\n最後，我要衷心感謝同濟大學、香港理工大學、澳門科技大學、世新大學以及逢甲大學的導師和學生，正是因為你們，我才度過了如此特別難忘的暑假！",
    "url": "https://vincent-s-blog.web.app/posts/algorithm/else-tags/2023暑期人工智能交流/"
  }
]